#!/usr/bin/env python

import os
import os.path
import shutil
import sys
import re
import pickle
from optparse import OptionParser

parser = OptionParser()

parser.add_option("-l", "--log", dest = "log",
                  help = "Log file generated by LAMMPS")

parser.add_option("-i", "--input", dest = "input",
                  help = "Input script file for LAMMPS (when \"log\" is specified, input parameters are read from log file.)")

parser.add_option("-t", "--traj", dest = "traj",
                  help = "Solution or reference trajectory file (dcd, xtc, atom or atom/mpiio format)")

parser.add_option("-r", "--rigid", dest = "rigid",
                  help = "Solute structure file (rigid solute) (pdb or data format)")

parser.add_option("-s", "--flexible", dest = "solute",
                  help = "Solute trajectory file (flexible solute) (dcd, xtc, atom or atom/mpiio format)")

parser.add_option("-d", "--div", dest = "div", type = "int",
                  help = "Number of sections divided into",
                  default = None)

parser.add_option("--minenergy", dest = "minenergy", type = "float",
                  help = "Minimum energy",
                  default = -20.0)

parser.add_option("-v", "--verbose", dest = "verbose", action = "store_true",
                  help = "Increase verbosity (for debug)",
                  default = False)

parser.add_option("-e", "--force_pme", dest = "forcepme", action = "store_true",
                  help = "Use PME in ERmod instead of PPPM employed in LAMMPS (deprecated)",
                  default = False)

(options, args) = parser.parse_args()

mode = "solution"

if options.rigid != None or options.solute != None:
    mode = "reference"

params = {}
try:
    ifh = file(".extraparam", "rt")
    carryover = pickle.load(ifh)
    ifh.close()

    if mode == "solution" and "sltpick" in carryover:
        params["sltspec"] = carryover["sltpick"]
    
except OSError:
    pass

def log(x):
    if options.verbose:
        print >> sys.stderr, x

def warn_or_error(x, col):
    prefix = ""
    suffix = ""
    if os.isatty(sys.stderr.fileno()):
        prefix = "\x1b[" + str(col) + ";1m"
        suffix = "\x1b[0m"
    print >> sys.stderr, prefix + x + suffix

def warn(x):
    warn_or_error("Warning: " + x, 33)

def error(x):
    warn_or_error("Error: " + x, 31)
    sys.exit(1)

def safe_close(fh):
    # asynchronous NFS may miss file creation
    # esp. combined with delayed allocation (ext4, XFS)
    fh.flush()
    os.fsync(fh.fileno())
    fh.close()

def check_exists(f):
    if not os.path.exists(f):
        error("file " + f + " does not exist")

if options.log == None:
    error("log file is not specified (try --help)")

if options.traj == None:
    error("trajectory file is not specified (try --help)")

check_exists("MDinfo")
check_exists("SltInfo")
check_exists(options.traj)
check_exists(options.log)
if options.input != "log":
    check_exists(options.input)
if options.rigid != None:
    check_exists(options.rigid)
if options.solute != None:
    check_exists(options.solute)

if options.rigid != None and options.solute != None:
    error("Rigid insertion structure (--rigid) and flexible insertion structure (--solute) cannot be specified simultaneously")

if mode == "reference":
    if os.path.basename(os.getcwd()) != "refs":
        warn("The option is specified for insertion (reference system), but current directory name does not match")
else:
    # solution
    if os.path.basename(os.getcwd()) != "soln":
        warn("The option is specified for solution system, but current directory name does not match")

def save_parameters_fe(temp):
    feparamf = "../parameters_fe"
    fh = open(feparamf, "wt")
    print >> fh, "&fevars"
    print >> fh, "inptemp=%f" % temp
    print >> fh, "/"
    safe_close(fh)

def parse_log():

    def interpret_param():

        if len(words) > 3 and words[0] == "boundary":
            dic["boundary"] = words[1] + words[2] + words[3]

        if len(words) > 5 and words[0] == "fix" and words[4] == "temp":
            log("Temperature:")
            if dic.has_key("temp"):
                log("(updated)")
            dic["temp"] = float(words[5])
            log(dic["temp"])

        if len(words) > 3 and words[0] == "fix" and words[3] == "nvt":
            log("Ensemble:")
            if dic.has_key("ensemble"):
                log("(updated)")
            dic["ensemble"] = "nvt"
            log(dic["ensemble"])

        if len(words) > 3 and words[0] == "fix" and words[3] == "npt":
            log("Ensemble:")
            if dic.has_key("ensemble"):
                log("(updated)")
            dic["ensemble"] = "npt"
            log(dic["ensemble"])

        if len(words) > 2 and words[0] == "pair_style":
            log("Pair style, Rcut(LJ,in), Rcut(LJ,out), Rcut(Coul):")
            if dic.has_key("pair_style"):
                log("(updated)")
            dic["pair_style"] = words[1]
            log(dic["pair_style"])
            if words[1] == "lj/cut/coul/cut":
                dic["cutoff_lj_in"]   = float(words[2])
                dic["cutoff_lj_out"]   = float(words[2])
                dic["cutoff_coul"] = dic["cutoff_lj_out"]
                if len(words) > 3:
                    dic["cutoff_coul"] = float(words[3])
            elif words[1] == "lj/cut/coul/long":
                dic["cutoff_lj_in"]   = float(words[2])
                dic["cutoff_lj_out"]   = float(words[2])
                dic["cutoff_coul"] = dic["cutoff_lj_out"]
                if len(words) > 3:
                    dic["cutoff_coul"] = float(words[3])
            elif words[1] == "lj/charmm/coul/long":
                dic["cutoff_lj_in"]   = float(words[2])
                dic["cutoff_lj_out"]   = float(words[3])
                dic["cutoff_coul"] = dic["cutoff_lj_out"]
                if len(words) > 4:
                    dic["cutoff_coul"] = float(words[4])
            else:
                error("Unsupported pair_style")
            log(dic["cutoff_lj_in"])
            log(dic["cutoff_lj_out"])
            log(dic["cutoff_coul"])

        if len(words) > 1 and words[0] == "kspace_style":
            dic["kspace_style"] = words[1]
            if( dic["kspace_style"] != "ewald" and dic["kspace_style"] != "pppm"):
                error("Unsupported kspace_style")

        if len(words) > 4 and words[0] == "dump":
            if words[3] not in ["xtc", "dcd", "atom", "atom/mpiio"] :
                error("Unsupported dump style")
            dic["dumpN"] = int(words[4])

        if len(words) > 1 and words[0] == "run":
            log("Number of steps:")
            if dic.has_key("run"):
                log("(updated)")
            dic["run"] = int(words[1])
            log(dic["run"])

    dic = {}
    dic["temp"] = 300.0

    logfh = open(options.log, "rt")
    for l in logfh:
        pos = l.find('#')
        if pos > -1:
            l = l[:pos]
        words = l.split()

        re_gewald=re.compile(r"^  G vector .1.distance. = (.*)$").match(l)
        if re_gewald:
            log("Ewald coefficient:")
            if dic.has_key("gewald"):
                log("(updated)")
            dic["gewald"] = float(re_gewald.group(1))
            log(dic["gewald"])

        re_order=re.compile(r"^  stencil order = (.*)$").match(l)
        if re_order:
            log("PPPM order:")
            if dic.has_key("pppm_order"):
                log("(updated)")
            dic["pppm_order"] = float(re_order.group(1))
            log(dic["pppm_order"])

        re_mesh=re.compile(r"^  grid = ([0-9]+) ([0-9]+) ([0-9]+)$").match(l)
        if re_mesh:
            log("PPPM mesh size:")
            if dic.has_key("meshx"):
                log("(updated)")
            dic["meshx"] = int(re_mesh.group(1))
            dic["meshy"] = int(re_mesh.group(2))
            dic["meshz"] = int(re_mesh.group(3))
            log(dic["meshx"])
            log(dic["meshy"])
            log(dic["meshz"])

        if options.input == "log":
            interpret_param()
            
    logfh.close()

    if options.input != "log":
        inpfh = open(options.input, "rt")
        for l in inpfh:
            pos = l.find('#')
            if pos > -1:
                l = l[:pos]
            words = l.split()
            interpret_param()
        inpfh.close()

    params["ljformat"] = 0
    params["cmbrule"]  = 1 # geometric
    params["inptemp"] = dic["temp"]
    params['ljswitch']  = 0

    if mode == "solution":
        save_parameters_fe(dic["temp"])

    if options.rigid:
        params['slttype'] = 2 # rigid
    elif options.solute:
        params['slttype'] = 3 # flexible
    else:
        params['slttype'] = 1 # solution

    if not dic.has_key("pair_style"):
        error("Keyword \"pair_style\" was not found in log file. Specify input script file by \"-i\" option.")

    params['upljcut'] = dic["cutoff_lj_out"]
    params['lwljcut'] = dic["cutoff_lj_in"]
    params['elecut'] = dic['cutoff_coul']
    if dic["pair_style"] == "lj/cut/coul/cut":
        params['cltype']  = 0
    elif dic["pair_style"] == "lj/cut/coul/long" or dic["pair_style"] == "lj/charmm/coul/long":
        if not dic.has_key("gewald"):
            error("Cannot read G vector parameter from log file. Specify input script file by \"-i\" option.")
        params['screen'] = dic["gewald"]
        if dic["kspace_style"] == "ewald":
            params['cltype'] = 1
        elif dic["kspace_style"] == "pppm":
            if options.forcepme:
                params['cltype'] = 2
                print "Note: PME will be used in ERmod insted of PPPM employed to get trajectories in LAMMPS (deprecated)"
            else:
                params['cltype'] = 3
            if not (dic.has_key("meshx") and dic.has_key("meshy") and dic.has_key("meshz")):
                error("Cannot read number of meshes for K-space from log file. Specify input script file by \"-i\" option.")
            params['ms1max'] = dic["meshx"]
            params['ms2max'] = dic["meshy"]
            params['ms3max'] = dic["meshz"]
            if not dic.has_key("pppm_order"):
                error("Cannot read stencil order for K-space from log file. Specify input script file by \"-i\" option.")
            params['splodr'] = dic["pppm_order"]
        else:
            error("Unsupported kspace_style")
    else:
        error("Unsuppoerted pair_style")
        
    if dic["boundary"] == "ppp":
        params['boxshp'] = 1
        is_periodic = True
    elif dic["boundary"] == "fff":
        params['boxshp'] = 0
        is_periodic = False
    else:
        error("Unsupported baoundary")

    if dic["ensemble"] == "nvt":
        params['estype'] = 1
    elif dic["ensemble"] == "npt":
        params['estype'] = 2
    else:
        error("Unsupported ensemble type")

    if options.div == None:
        if mode == "reference":
            params["engdiv"] = 5
        else:
            params["engdiv"] = 10
    else:
        params["engdiv"] = options.div
    
    ofh = open("parameters_er", "wt")
    print >> ofh, "&ene_param"
    keys = params.keys()
    keys.sort()
    for k in keys:
        v = params[k]
        if isinstance(v, str):
            print >> ofh, "        %s = \"%s\"," % (k, v)
        elif isinstance(v, int):
            print >> ofh, "        %s = %d," % (k, v)
        elif isinstance(v, float):
            print >> ofh, "        %s = %g," % (k, v)
        else:
            error("Unknown output type")
    
    print >> ofh, """/
&hist
      eclbin=5.0e-2, ecfbin=2.0e-3, ec0bin=2.0e-4, finfac=10.0e0,
      ecdmin=%f, ecfmns=-0.20e0, ecdcen=0.0e0, eccore=20.0e0,
      ecdmax=1.0e11, pecore=200
/
""" % options.minenergy

    if int(dic["dumpN"]) != 0:
        frames = int(dic["run"]) / int(dic["dumpN"]) + 1

    return (frames, is_periodic)
    
(frames, is_periodic) = parse_log()

# update MDinfo
if frames:
    ifh = open("MDinfo", "rt")
    ofh = open("MDinfo.new", "wt")
    l = ifh.next().split()
    print >> ofh, frames, l[1]
    print >> ofh, ifh.next().strip()
    print >> ofh, ifh.next().strip()
    ifh.close()
    safe_close(ofh)
    shutil.move("MDinfo", "MDinfo.bak")
    shutil.move("MDinfo.new", "MDinfo")

def symlink(src, dest):
    if os.path.exists(dest):
        if os.path.islink(dest):
            # renew link
            os.remove(dest)
        else:
            return
    os.symlink(src, dest)

# link or generate trajectory
(_, ext) = os.path.splitext(options.traj)
symlink(options.traj, "HISTORY")

if options.solute:
    # flexible
    symlink(options.solute, "SltConf")

elif options.rigid:
    def get_pdb_coord():
        # fixed
        fh = open(options.rigid, "rt")
        coords = []
        # overwrite SltInfo with coordinate information
        for l in fh:
            if l[0:4] == "ATOM" or l[0:6] == "HETATM":
                coords.append((float(l[30:38]), float(l[38:46]), float(l[46:54])))
        fh.close()
        return coords

    def get_data_coord():
        fh = open(options.rigid, "rt")
        coords = []
        natom  = 0
        iatom  = 0
        read_atom = False
        for l in fh:
            pos = l.find('#')
            if pos > -1:
                l = l[:pos]

            words = l.split()
            if len(words) == 0:
                continue
            
            if len(words) > 1 and words[1] == "atoms":
                natom  = int(words[0])
                coords = [(0.0, 0.0, 0.0)] * natom
                continue
            
            if words[0] == "Atoms":
                read_atom = True
                continue

            if read_atom:
                if len(words) < 7:
                    error("Invalid line in data file")
                x = float(words[4])
                y = float(words[5])
                z = float(words[6])
                coords[iatom] = (x, y, z)
                iatom += 1
                if iatom == natom:
                    break;
               
        fh.close()
        return coords

    (_, ext) = os.path.splitext(options.rigid)
    if ext == ".pdb" or ext == ".PDB":
        coords = get_pdb_coord()
    else:
        coords = get_data_coord()
    
    ifh = open("SltInfo", "rt")
    ofh = open("SltInfo.new", "wt")
    pos = 0
    for l in ifh:
        print >> ofh, ' '.join((l.split())[0:5]), coords[pos][0], coords[pos][1], coords[pos][2]
        pos += 1

    ifh.close()
    safe_close(ofh)
    shutil.move("SltInfo", "SltInfo.bak")
    shutil.move("SltInfo.new", "SltInfo")

log('normally finished.')
