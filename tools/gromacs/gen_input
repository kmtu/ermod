#!/usr/bin/env python

import os
import os.path
import shutil
import sys
import re
import pickle
import subprocess
from optparse import OptionParser

parser = OptionParser()

parser.add_option("-l", "--log", dest = "log",
                  help = "Log file generated by mdrun")

parser.add_option("-x", "--traj", dest = "traj",
                  help = "Solution or reference trajectory file (in g96 format)")

parser.add_option("-p", "--pdb", dest = "pdb",
                  help = "Solute structure PDB file (rigid solute)")

parser.add_option("-s", "--flexible", dest = "solute",
                  help = "Solute trajectory file (flexible solute)")

parser.add_option("-d", "--div", dest = "div", type = "int",
                  help = "Number of sections divided into",
                  default = None)


parser.add_option("--minenergy", dest = "minenergy", type = "float",
                  help = "Minimum energy",
                  default = -20.0)

parser.add_option("-v", "--verbose", dest = "verbose", action = "store_true",
                  help = "Increase verbosity (for debug)",
                  default = False)

(options, args) = parser.parse_args()

params = {}
try:
    ifh = file(".extraparam", "rt")
    carryover = pickle.load(ifh)
    ifh.close()

    params["ljformat"] = {
        'C6C12': 4,
        'sigeps': 2
        }[carryover["ljformat"]]

    params["cmbrule"] = {
        'geometric': 1,
        'arithmetic': 0
        }[carryover["ljtype"]]
    
except OSError:
    pass

def log(x):
    if options.verbose:
        print >> sys.stderr, x

def warn_or_error(x):
    prefix = ""
    suffix = ""
    if os.isatty(sys.stderr.fileno()):
        prefix = "\x1b[31;1m"
        suffix = "\x1b[0m"
    print >> sys.stderr, prefix + x + suffix

def warn(x):
    warn_or_error("Warning: " + x)

def error(x):
    warn_or_error("Error: " + x)
    sys.exit(1)

if options.log == None:
    error("log file is not specified (try --help)")

if options.traj == None:
    error("trajectory file is not specified (try --help)")

def check_exists(f):
    if not os.path.exists(f):
        error("file " + f + " does not exist")

check_exists("MDinfo")
check_exists("SltInfo")
check_exists(options.traj)
check_exists(options.log)
if options.pdb:
    check_exists(options.pdb)
if options.solute:
    check_exists(options.solute)

# TODO: ljformat

def parse_mdp():
    logfh = open(options.log, "rt")
    pats = re.compile(r"^\s*([a-zA-Z0-9_]+)\s*=\s*(\S+)\s*$")
    reft = re.compile(r"^\s+ref_t:\s+(\d+)")
    beta = re.compile(r"Using a Gaussian width \(1/beta\) of (\S+) nm for Ewald")
    dic = {}
    temp = 300.0
    betawidth = None

    for l in logfh:
        pairs = pats.match(l)
        if pairs:
            dic[pairs.group(1)] = pairs.group(2)

        reftf = reft.match(l)
        if reftf:
            temp = float(reftf.group(1))

        betaf = beta.match(l)
        if betaf:
            betawidth = float(betaf.group(1))

    logfh.close()

    params["inptemp"] = temp

    if options.pdb:
        params['slttype'] = 2 # rigid
    elif options.solute:
        params['slttype'] = 3 # flexible
    else:
        params['slttype'] = 1 # solution

    if dic["vdwtype"] == "Cut-off":
        cutoff = float(dic["rvdw"]) * 10.0 # nm -> angstrom
        params['upljcut'] = cutoff
        params['lwljcut'] = cutoff
    elif dic["vdwtype"] == "Switch":
        params['upljcut'] = float(dic["rvdw"]) * 10.0
        params['lwljcut'] = float(dic["rvdw_switch"]) * 10.0
    elif dic["vdwtype"] in ["Shift", "Encad-Shift"]:
        warn("Warning: shifted L-J potential is not supported; using switched L-J (may cause inconsistent result)")
        params['upljcut'] = float(dic["rvdw"]) * 10.0
        params['lwljcut'] = float(dic["rvdw_switch"]) * 10.0
    else:
        warn("Warning: unknown vdwtype; please specify vdw parameters manually")

    if dic["ePBC"] == "xyz":
        params['boxshp'] = 1
        is_periodic = True
    else:
        params['boxshp'] = 0
        is_periodic = False

    if dic["coulombtype"]  == "Cut-off":
        params['cltype'] = 0
        cutoff = float(dic['rcoulomb']) * 10.0
        params['elecut'] = cutoff
    if dic["coulombtype"] == "Ewald":
        params['cltype'] = 1
        cutoff = float(dic['rcoulomb']) * 10.0
        params['elecut'] = cutoff
    if dic["coulombtype"] == "PME":
        params['cltype'] = 2
        cutoff = float(dic['rcoulomb']) * 10.0
        params['elecut'] = cutoff
        params['ms1max'] = int(dic['nkx'])
        params['ms2max'] = int(dic['nky'])
        params['ms3max'] = int(dic['nkz'])
        params['splodr'] = int(dic['pme_order'])
        params['screen'] = 1. / (betawidth * 10.0)
        
    if dic["epc"] == "No":
        params['estype'] = 1
    elif dic["epc"] in ["Berendsen", "Parrinello-Rahman"]:
        params['estype'] = 2
    else:
        warn("Warning: Unknown pressure coupling type, check log / output")
        params['simtype'] = 1

    if options.div == None:
        if options.solute != None or options.pdb != None:
            params["engdiv"] = 5
        else:
            params["engdiv"] = 10
    else:
        params["engdiv"] = options.div
    
    ofh = open("parameters_er", "wt")
    print >> ofh, "&ene_param"
    keys = params.keys()
    keys.sort()
    for k in keys:
        v = params[k]
        if isinstance(v, str):
            print >> ofh, "        %s = \"%s\"," % (k, v)
        elif isinstance(v, int):
            print >> ofh, "        %s = %d," % (k, v)
        elif isinstance(v, float):
            print >> ofh, "        %s = %g," % (k, v)
        else:
            error("Unknown output type")
    
    print >> ofh, """/
&hist
      eclbin=5.0e-2, ecfbin=2.0e-3, ec0bin=2.0e-4, finfac=10.0e0,
      ecdmin=%f, ecfmns=-0.20e0, ecdcen=0.0e0, eccore=20.0e0,
      ecdmax=1.0e11, pecore=200
/
""" % options.minenergy

    if int(dic["nstxtcout"]) != 0:
        frames = int(dic["nsteps"]) / int(dic["nstxtcout"])
    else:
        frames = int(dic["nsteps"]) / int(dic["nstxout"])
    return (frames, is_periodic)
    
(frames, is_periodic) = parse_mdp()

# update MDinfo
if frames:
    ifh = open("MDinfo", "rt")
    ofh = open("MDinfo.new", "wt")
    l = ifh.next().split()
    print >> ofh, frames, l[1]
    print >> ofh, ifh.next().strip()
    print >> ofh, ifh.next().strip()
    ifh.close()
    ofh.close()
    shutil.move("MDinfo", "MDinfo.bak")
    shutil.move("MDinfo.new", "MDinfo")

def symlink(src, dest):
    if os.path.exists(dest):
        if os.path.islink(dest):
            # renew link
            os.remove(dest)
        else:
            return
    os.symlink(src, dest)

def convtraj(src, trunk):
    if trunk == "HISTORY":
        symlink(src, trunk)
        return
    retcode = subprocess.call(["trjconv", "-f", src, "-o", trunk + ".g96", "-novel"])
    if retcode != 0:
        retcode = subprocess.call(["trjconv_d", "-f", src, "-o", trunk + ".g96", "-novel"])
    assert(retcode == 0)
    symlink(trunk + ".g96", trunk)

# link or generate trajectory
(_, ext) = os.path.splitext(options.traj)
if ext != ".g96":
    log("Trajectory is not g96 file, converting files")
    convtraj(options.traj, "HISTORY")
else:
    log("Trajectory is g96 file, linking to HISTORY")
    symlink(options.traj, "HISTORY")

if options.solute:
    # flexible
    (_, ext) = os.path.splitext(options.solute)
    if ext != ".g96":
        log("Solute trajectory is not g96 file, converting files")
        convtraj(options.solute, "SltConf")
    else:
        log("Solute trajectory is g96 file, linking to HISTORY")
        symlink(options.solute, "SltConf")
elif options.pdb:
    # fixed
    fh = open(options.pdb, "rt")
    coords = []
    # overwrite SltInfo with coordinate information
    for l in fh:
        if l[0:4] == "ATOM" or l[0:6] == "HETATM":
            coords.append((float(l[30:38]), float(l[38:46]), float(l[46:54])))
    fh.close()
    ifh = open("SltInfo", "rt")
    ofh = open("SltInfo.new", "wt")
    pos = 0
    for l in ifh:
        print >> ofh, ' '.join((l.split())[0:5]), coords[pos][0], coords[pos][1], coords[pos][2]
        pos += 1
    ifh.close()
    ofh.close()
    shutil.move("SltInfo", "SltInfo.bak")
    shutil.move("SltInfo.new", "SltInfo")
